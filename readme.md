# goit-algo-hw-09 — Жадібні алгоритми та динамічне програмування

## Опис
Потрібно реалізувати дві функції для видачі решти монетами з набору:
`[50, 25, 10, 5, 2, 1]`

- `find_coins_greedy(amount)` — жадібний алгоритм
- `find_min_coins(amount)` — динамічне програмування (мінімум монет)

Обидві функції повертають словник `{номінал: кількість}`.

## Жадібний алгоритм (find_coins_greedy)
Логіка: завжди беремо найбільшу монету, яка поміщається в залишок суми.

Приклад для 113:
`{50: 2, 10: 1, 2: 1, 1: 1}`

**Складність:**
- Час: `O(k)`, де `k` — кількість номіналів (тут k=6)
- Пам’ять: `O(1)`

Працює дуже швидко навіть на великих сумах, бо монет всього 6 типів.

## Динамічне програмування (find_min_coins)
Логіка: рахуємо мінімальну кількість монет для всіх сум від `1` до `amount`.
Зберігаємо, яку монету взяли останньою, і потім відновлюємо відповідь.

Приклад для 113:
Отримаємо ті ж самі монети, просто порядок ключів у словнику може відрізнятись.

**Складність:**
- Час: `O(amount * k)`
- Пам’ять: `O(amount)`

На великих сумах це повільніше, бо треба пройти всі значення до `amount`.

## Висновок
Для цього набору монет жадібний алгоритм дає оптимальний результат і працює швидше, тому для касового апарату він вигідніший.

DP корисний, коли набір номіналів може бути інший (нестандартні монети), бо він гарантує мінімальну кількість монет, але за це платить часом і пам’яттю на великих сумах.
